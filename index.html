<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="sp不会玩ps">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sp不会玩ps">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sp不会玩ps">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> sp不会玩ps </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">sp不会玩ps</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-project">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-leaf fa-fw"></i> <br />
            
            项目
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第四章/第四章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第四章、View的工作原理"><a href="#第四章、View的工作原理" class="headerlink" title="第四章、View的工作原理"></a>第四章、View的工作原理</h3><pre><code>&gt; 为了更好的自定义View，还需要掌握View底层工作原理，比如View的测量布局，布局流程以及绘制流程。掌握了这几个流程后，我们就对View的底层更加了解，这样就可以做出一个比较完善的自定义View。
</code></pre><ol>
<li><p>ViewRoot和DecorView</p>
<ol>
<li>View的绘制流程是从ViewToot的performTraversals方法开始的，经过的measure、layout和draw三个过程才能最终将一个View绘制出来。其中measure用来测量View的宽和高，layout用来确定View在父容器的放置位置，draw负责将View绘制在屏幕上。</li>
<li>performTraversals 会依次调用performMeasure,performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中performMeasure会调用measure，measure中又会调用onMeasure方法，在onMeasure方法中则会对所有的子元素进行measure，这个时候measure就从父容器传递到了子元素中，这样就完成了一次measure过程，接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。</li>
<li>performLayout和performDraw的传递流程同performMeasure一样。</li>
</ol>
</li>
<li><p>理解MeasureSpec</p>
<blockquote>
<p>MeasureSpec 在很大程度上确定了一个View的尺寸规则，之所以说是很大程度上是因为这个过程还受父容器的影响，因为父容器影响View的MeasureSpec的创建过程。在测量过程中，根据父容器所施加的规则，系统会将View的LayoutParams转换成对应的MeasureSpec，然后再根据这个measureSpec来测量出View的宽高。</p>
</blockquote>
<ol>
<li>MeasureSpec  <ul>
<li>MessureSpec代表了一个32int值，高两位代表SpecMode,低两位代表了SpecSize。SpecMode是指测量模式，SpecMode是指在某种测量模式下的规格大小。  </li>
<li>MeasureSpec通过将SpceMode和SpecSize打包成一个int值来避免过多的对象内存分配问题。为了方便，其提供了打包解包方法。SpecMode和SpceSize也是一个int值。</li>
<li>SpecMode有三类：<ol>
<li>UNSPECIFIED： 父容器不对View有任何限制、，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</li>
<li>EXACTLY： 父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值，它对应于LayoutParams中march_parent和具体数值这两种模式。</li>
<li>AT_MOST: 父容器指定一个可用大小即SpecSize，View大小不能大于这个值。对应于LayoutParams中的wrap_content.</li>
</ol>
</li>
</ul>
</li>
<li><p>MeasureSpec 和LayoutParams的对应关系  </p>
<blockquote>
<p>对于顶级View和普通View(即DecorView)来说，MeasureSpce的转换过程略有不同，对于DecorView,其MeasureSpce由窗口尺寸和其自身的LayoutParams来共同确定；对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽高了。</p>
</blockquote>
<ol>
<li><p>DecorView的MeasureSpce的产生，遵守以下规则:</p>
<ol>
<li>LayoutParams.MATCH_PARENT:精确模式,大小就是窗口的大小。</li>
<li>LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小。</li>
<li>固定大小：精确模式，大小为LayoutParams中指定的大小。</li>
</ol>
</li>
<li><p>不同父容器和不同layoutParams,产生不同MesureSpec:</p>
<ol>
<li>当View采用固定宽/高的时候，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式并且其大小遵循LayouParams中的大小。</li>
<li>当View的宽/高是match_parent时，如果父容器的模式是精确模式，那么View也是精确模式并且其大小是父容器的剩余空间；如果父容器是最大模式，那么View也是最大模式并且其大小不会超过父容器的剩余空间。</li>
<li>当view的宽/高是wrap_content时，不管父容器的模式是精确还是最大化模式，View的模式总大化并且大小不能超过父容器的剩余空间。</li>
<li>UNSPECIFIED模式，一般不考虑这种模式，以为这个模式主要用于系统内部多次measure的情形。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>View工作流程</p>
<ol>
<li><p>View的measure过程</p>
<blockquote>
<p>measure过程要分情况来看，如果只是一个原始的View，那么通过measure就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历调用所有子元素的measure方法，各个子元素再递归去执行这个流程。</p>
</blockquote>
<ol>
<li>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在wrap_content就相当于使用match_content。</li>
<li>解决上面的问题，只需要给View指定一个默认的内部宽/高并在wrap_content时设置宽/高即可。对于非wrap_content情形，我们沿用系统的测量值即可，至于这个默认内部宽/高的大小如何制指定，没有固定依据，根据需要灵活制定即可。</li>
</ol>
</li>
<li><p>ViewGroup的measure过程</p>
<ol>
<li>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有的子元素的measure方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个叫measureChildren的方法。measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec方法来创建子元素的MeasureSpec，接着将measureSpece直接传递给View的measure方法进行测量。</li>
<li>为什么ViewGroup不想View一样对其onMeasure方法做统一的实现？<br>因为不同的ViewGroup子类有着不同的布局特性，这导致它们的测量细节各不相同。</li>
<li>View的measure过程是三大流程中最复杂的一个，measure完成以后，通过getMeasuredWidth/Height方法就可以正确地获取到View的测量宽/高.需要注意的是，在某些嫉妒啊你情况下，系统可能需要多次measure才能确定最终的测量宽/高，这种情形下，在onMeasure方法拿到测量宽高可能是不准确的。一个良好的习惯是在<strong>onLayout</strong>方法中去获取View的测量宽高</li>
<li>在onCreate、onStart、onResume中均无法正确得到整个View的宽、高信息，这是因为View的measure过程和Activity的生命周期方法不是同步执行的，因为无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，如果View还没有测量完毕，那么获得的宽、高就是0，解决方法如下:  <ol>
<li>Activity/View#onWindowFocusChanged.<br> 表示View已经初始化完毕了，注意会被调用多次，Activity的窗口得到焦点和失去焦点均会被调用。</li>
<li>view.post(runnable)<br> 通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View已经初始化好了。</li>
<li>ViewTreeObserver  </li>
<li>View.measure(int widthMeasureSpc,int heightMeasureSpec)</li>
</ol>
</li>
</ol>
</li>
<li><p>layout过程</p>
<blockquote>
<p>当ViewGroup的位置被确定后，它在onLayout会遍历所有的子元素并调用其layout方法，在layout方法中onLayout方法又会被调用。layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置。  </p>
</blockquote>
<ol>
<li>View的getMeasuredWidth和getWidth这两个方法的区别？<br> 在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的layout过程，即两者的赋值时机不同。但是的确存在某些特殊情况会导致两者情况不一致。</li>
</ol>
</li>
<li>draw过程<br> View的作用就是将View绘制到屏幕上面。View的绘制过程遵循如下几步:<ol>
<li>绘制背景 (backgroud.draw(canvas))</li>
<li>绘制自己 (onDraw())</li>
<li>绘制children（dispatchDraw)</li>
<li>绘制装饰 (onDrawScrollBars)</li>
</ol>
</li>
</ol>
</li>
<li><p>自定义View</p>
<ol>
<li>自定义View的分类：<ol>
<li>继承View重写onDraw方法<br> 采用这种方法需要自己支持wrap_content,并且padding也需要自己处理。</li>
<li>继承ViewGroup派生特殊的Layout<br> 需要合适地处理ViewGroup的测量、布局这两个过程。</li>
<li>继承特定的View(比如TextView)<br> 不需要自己支持wrap_content和padding</li>
<li>继承特定的ViewGroup(比如LinearLayout)<br> 不需要自己处理ViewGroup的测量和布局。</li>
</ol>
</li>
<li>注意事项：<ol>
<li>让View支持wrap_content</li>
<li>如果有必要，让你的View支持padding</li>
<li>尽量不要在View中使用Handler。view本身就提供了post系列方法。</li>
<li>View中如果有线程或者动画，需要及时停止，当包含此View的Activity退出或者当前View被remove时，View的ononDetachedFromWindow会被调用。</li>
<li>View带有滑动嵌套情形时，需要处理好滑动冲突。</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第六章/第六章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第六章、android的Drawable"><a href="#第六章、android的Drawable" class="headerlink" title="第六章、android的Drawable"></a>第六章、android的Drawable</h3><ol>
<li>Drawable 简介<br> Drawable有很多种，它们都表示一中图像的概念，但是它们又不全是图片，通过颜色也可以构造出各式各样的图像效果。在实际开发中，Drawable常用来作为View的背景使用。Drawable一般都是通过XML来定义的，我们也可用通过代码来创建具体的Drawable对象。</li>
<li><p>Drawable的分类 </p>
<ol>
<li><p>BitmapDrawable 、NinePatchDrawable<br> 代码如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;bitmap / nine-patch
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:src=&quot;@[package:]drawable/drawable_resource&quot;
    android:antialias=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:filter=[&quot;true&quot; | &quot;false&quot;]
    android:gravity=[&quot;top&quot; | &quot;bottom&quot; | &quot;left&quot; | &quot;right&quot; | &quot;center_vertical&quot; |
                      &quot;fill_vertical&quot; | &quot;center_horizontal&quot; | &quot;fill_horizontal&quot; |
                      &quot;center&quot; | &quot;fill&quot; | &quot;clip_vertical&quot; | &quot;clip_horizontal&quot;]
    android:tileMode=[&quot;disabled&quot; | &quot;clamp&quot; | &quot;repeat&quot; | &quot;mirror&quot;] /&gt;
</code></pre><ol>
<li>各个属性的含义:  <ol>
<li>android:antialias:是否开启图片抗锯齿功能。开启后会让图片变得平滑，同时也会在一定程度上降低图片清晰度，但是降低幅度可以忽略不计，因此抗锯齿选项应该开启。</li>
<li>android:dither: 是否开启抖动效果。当图片的像素配置和手机屏幕配置不一致时，开启这个选项可以让高质量的图片在低质量上还能保证较好的显示效果。抖动效果应该开启。</li>
<li>android:filter：是否开启过滤效果。当图片尺寸被拉伸或者压缩时，开启过滤效果可以保证较好的显示效果。因此此选项也应该开启。</li>
<li>平铺模式，有四种选项[“disabled” | “clamp” | “repeat” | “mirror”]。当开启平铺模式后，gravity属性会被忽略。repeat是指水平和竖直方向上的平铺效果；mirror是指在水平和竖直方向上的镜面投影效果；clamp是指图片四周的像素会扩展到周围区域，这个比较特别。</li>
</ol>
</li>
</ol>
</li>
<li><p>ShapeDrawable</p>
<pre><code>ShapeDrawable是一种常见的Drawable，可以理解通过颜色来构造图形，它即可以是纯色图形，也可以是具有渐变效果的图形。  
**代码如下：**  

&lt;shape    
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt;    
&lt;corners        //当shape为rectangle时使用
    android:radius=&quot;integer&quot;        //半径值会被后面的单个半径属性覆盖，默认为1dp
    android:topLeftRadius=&quot;integer&quot;        
    android:topRightRadius=&quot;integer&quot;        
    android:bottomLeftRadius=&quot;integer&quot;        
    android:bottomRightRadius=&quot;integer&quot; /&gt;    
&lt;gradient       //渐变
    android:angle=&quot;integer&quot;        
    android:centerX=&quot;integer&quot;        
    android:centerY=&quot;integer&quot;        
    android:centerColor=&quot;integer&quot;        
    android:endColor=&quot;color&quot;        
    android:gradientRadius=&quot;integer&quot;        
    android:startColor=&quot;color&quot;        
    android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]        
    android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt;    
&lt;padding        //内边距
    android:left=&quot;integer&quot;        
    android:top=&quot;integer&quot;        
    android:right=&quot;integer&quot;        
    android:bottom=&quot;integer&quot; /&gt;    
&lt;size           //指定大小，一般用在imageview配合scaleType属性使用
    android:width=&quot;integer&quot;        
    android:height=&quot;integer&quot; /&gt;    
&lt;solid          //填充颜色
    android:color=&quot;color&quot; /&gt;    
   &lt;stroke         //边框
      android:width=&quot;integer&quot;        
    android:color=&quot;color&quot;        
    android:dashWidth=&quot;integer&quot;        
    android:dashGap=&quot;integer&quot; /&gt;
</code></pre><p> </p>
</li>
<li><p>LayerDrawer  </p>
<pre><code>LayerDrawer对应的XML标签是&lt;lay-list&gt;，它表示一种层次化的Drawable集合，通过将不同的Drawable放置在不同的层上面从而达到一种叠加后的效果。默认情况下，laywer-list中的所有的Drawable都会被缩放至View的大小。
</code></pre></li>
<li>StateListDrawable  <pre><code>StateListDrawable 对应于&lt;selector&gt;标签，它也是表示Drawable集合，每个Drawable都对应着View的一种状态，这样系统就会根据View的状态来选择合适的Drawable。StatelistDrawable主要用于设置可单击的View的背景。
</code></pre></li>
<li>LevelListDrawable  <pre><code>对应于&lt;levle-list&gt;标签，它同样表示一个Drawable集合，集合中的每个Drawable都有一个等级的概念。根据不同的等级，LevelListDrawable会切换为对应的Drawable。
</code></pre></li>
<li>TransitionDrawable<pre><code>TransitionDrawable对应于&lt;transition&gt;标签，它用于实现两个Drawable之间的淡入淡出效果。
</code></pre></li>
<li>InsetDrawable<pre><code>InsetDrawable对应于&lt;inset&gt;标签，它可以将其它Drawable内迁到自己当中，并可以在四周留出一定的间距。当一个View希望自己的背景比自己的实际区域小的时候，可以采用InsetDrawable来实现。
</code></pre></li>
<li>ScaleDrawable  <pre><code>对应&lt;scale&gt;标签，它可以根据自己的等级将指定的Drawable缩放到一定的比例。
</code></pre></li>
<li>ClipDrawable<pre><code>对应&lt;clip&gt;标签，它可以根据自己当前的等级来裁剪另一个Drawable，裁剪方向可以通过android:clicpOperatioin和android.gravity这两个属性来共同控制。等级越大，表示裁剪和区域越小，因此等级10000表示不裁剪，这个时候整个图片都可以完全显示出来；等级0表示裁剪全部区域，这个时候整个图片将不可见。
</code></pre></li>
</ol>
</li>
<li>自定义Drawable<br> 通常我们没有必要去自定义Drawable,这是因为自定义的Drawable无法再XML中使用，这就降低了自定义Drawable的适用范围。某些特殊情况下我们的确想自定义Drawable，这也是可以的。</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第八章/第八章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第八章、理解Window和WindowManager"><a href="#第八章、理解Window和WindowManager" class="headerlink" title="第八章、理解Window和WindowManager"></a>第八章、理解Window和WindowManager</h3><pre><code>&gt; Window表示一个窗口的概念。Window是一个抽象类，它的具体表现是PhoneWindow。通过WindowManager即可创建一个Window。Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerServide的交互是一个IPC的过程。Android的中所有的视图都是通过Window呈现的，Window实际上是View的直接管理者。
</code></pre><ol>
<li><p>Window和WindowManager  </p>
<ol>
<li><p>演示通过WindowManager添加Window的过程    </p>
<pre><code>mFloatingButton = new Button(this);
mFloatingButton.setText(&quot;test button&quot;);
mLayoutParams = new WindowManager.LayoutParams(
        LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 0, 0,
        PixelFormat.TRANSPARENT);//0,0 分别是type和flags参数，在后面分别配置了
mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL
        | LayoutParams.FLAG_NOT_FOCUSABLE
        | LayoutParams.FLAG_SHOW_WHEN_LOCKED;
mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR;
mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP;
mLayoutParams.x = 100;
mLayoutParams.y = 300;
mFloatingButton.setOnTouchListener(this);
mWindowManager.addView(mFloatingButton, mLayoutParams);
</code></pre></li>
<li>Window常用的几个Flags属性<ol>
<li>FLAG_NOT_FOCUSABLE:<br> 表示Window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的Window。</li>
<li>FLAG_NOT_TOUCH_MODAL：<br> 在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记</li>
<li>FLAG_SHOW_WHEN_LOCKED:<br> 开启此模式可以让Window显示在锁屏的界面上。</li>
</ol>
</li>
<li>Type参数表示Window的类型，有三种类型：<ol>
<li>应用Window：<br> 对应着一个Activity</li>
<li>子Window:<br> 子View不能单独存在，需要依附在特定的富Window之中，比如常见的Dialog</li>
<li>系统Window：<br> 系统Window是需要申明权限才能创建Window。比如Toast和系统状态栏都是系统Window。</li>
</ol>
</li>
<li><p>Window是分层的，层级大的会覆盖在层级小的Window的上面。</p>
<ol>
<li>应用Window的层级范围：1-99</li>
<li>子Window的层级范围：1000-1999</li>
<li>系统Window的层级范围：2000-2999</li>
</ol>
</li>
<li><p>WindowManager提供的有三个常用的方法：</p>
<ol>
<li>添加View</li>
<li>更新View</li>
<li>删除View</li>
</ol>
</li>
</ol>
</li>
<li><p>Window的内部机制</p>
<ol>
<li>Window是一个抽象概念，Window并不是实际存在的，它是以View的形式存在的。View才是Window存在的实体。</li>
<li>Window的添加过程需要通过WindowManager的addView来实现。它的真正实现是WindowManagerImpl类，WindowManagerImpl并没有直接实现window的三大操作，而是全部交给了WindowManagerClobal来处理。。这种事典型的桥接模式。</li>
<li><p><strong>WindowManagerGlobal的addView过程：</strong></p>
<ol>
<li>检查参数是否合法，如果是子Window那么还需要调整一些布局参数。</li>
<li>创建ViewRootImpl并将View添加到列表中</li>
<li>通过ViewRootImpl来更新界面并完成Window的添加过程。</li>
</ol>
</li>
<li><p><strong> WindowManagerGlobal的removeView过程：</strong>  </p>
<ol>
<li>首先通过findViewLocked来查找待删除的View的索引，查找的过程就是遍历数组，然后再通过removeViewLocked来做进一步的删除。  </li>
<li>removeLocked是通过ViewRootImpl来完成删除的。两种删除接口，removeView和removeViewImmediate。分别代表异步删除和同步删除。一般不使用同步删除。  </li>
<li>removeLocked里面会调用die方法，如果是异步删除，将其添加到待删除列表中，同时发送一个MSG_DIE的消息，ViewRootImpl中的Handler会处理此消息并调用doDie方法 。如果是同步删除，不发送消息，直接调用doDie方法。doDie最后调用了dispatchDetachedFromWindow方法。  </li>
<li>dispatchDetachedFromWindow主要流程：  <ol>
<li>垃圾回收  </li>
<li>通过Session的remove方法删除Window，最终调用WindowManagerService的removeWindow方法  </li>
<li>调用View的dispatchDetachedFromWindow方法。当View从Window中移除时，会调用onDetachedFromWindow()方法，这个方法内部可以做一些资源回收工作。  </li>
<li>调用windowManagerGlobal的doRemoveView方法刷新数据。  </li>
</ol>
</li>
</ol>
</li>
<li><strong>WindowManagerGlobal的更新过程</strong>  <ol>
<li>更新View的LayoutParams并将老的LayoutParams替换掉。  </li>
<li>更新ViewRootImpl中的LayoutParams。通过setLayoutParams来完成的。  </li>
<li>通过scheduleTraversals来对View重新布局，包括测量，布局，重绘三个过程。  </li>
</ol>
</li>
</ol>
</li>
<li><p>Window的创建过程</p>
<blockquote>
<p>View 是Android中的视图呈现方式，有视图的地方就有Window。</p>
</blockquote>
<ol>
<li><p>Acitivity的Window创建过程：</p>
<ol>
<li>在ActivityThread中的performLanunchActivity()来完成整个启动过程，方法内部会创建Activity实例对象，并通过attach方法为其关联运行中所需要的环境变量。  </li>
<li>attach方法里，系统会创建Activity所属的Window对象，并为其设置回调接口。由于Activity实现了Window的回回调接口，所有当Window接收到外界状态改变时，就会回调Activity的方法。</li>
<li>Activity将具体实现交给了Window，Window的具体处理是PhoneWindow，所以只需要看PhoneWindow相关逻辑即可。PhoneWindow的setContentView方法大致如下几个步骤:  <ol>
<li>没有DecorView，就创建它。</li>
<li>将View添加到DecorView的mContentParent中</li>
<li>回调Activity的onContentChanged方法通知Activity视图已经发生了变化。</li>
<li>此时DecorView并没有被WindowManager识别，所以这个时候的Window无法提供具体功能。在ActivityThread的handleResumeActivity方法中，首先会调用Activity的onResume方法，接着会调用Activity的makeVisible()，在makeVisiable中，DecorView真正完成了添加和显示两个过程，此时Activity的视图才能被用户看到。</li>
</ol>
</li>
</ol>
</li>
<li><p>Dialog的window创建过程</p>
<ol>
<li>创建Window</li>
<li>初始化DecorView并将Dialog的视图添加到DecorView中</li>
<li><p>将DecorView添加到window并显示。</p>
<blockquote>
<p>普通Dialog有一个特殊之处，那就是必须采用Activity的Context，如果采用Application的Context，那么就会报错。<br>报错的信息就是没有应用token所致的。token一般只有Activity拥有，所以只需要用Activity作为Context来显示对话框即可。但是系统Window比较特殊，不需要token。所以只需要指定对话框的Window为系统类型就可正常弹出对话框。<br>dialog.getWindow().setType(LayoutParams.TYPE_SYSTEM_ERROR)<br>最后在AndroidManifest文件中声明权限就可以了。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>Toast创建过程  </p>
<ol>
<li>Toast由于具有定时取消的功能，所以系统采用了Handler在Toast内部有两类IPC，第一类是Toast访问NotificationManagerService (NMS),第二类是NotificationManagerService会调Toast里的TN接口。  </li>
<li>Toast属于系统Window，内部视图有两种方式指定。系统默认和通过setView方法来指定一个View。</li>
<li>Toast提供了show和cancel分别用于显示和隐藏Toast。它们的内部是一个IPC过程。</li>
<li>Toast显示和隐藏都是通过NMS来实现，NMS运行在系统进程中。NMS处理Toast请求时会跨进程调用TN中的方法。TN运行在Binder线程池中，所以通过Handler切换到当前线程。Handler需要使用Looper才能完成线程切换。</li>
<li>对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第五章/第五章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###第五章、理解RemoteView</p>
<blockquote>
<p>RemoteView在Android中的使用场景有两种:通知栏和桌面小部件。</p>
</blockquote>
<ol>
<li><p>RemoteViews的应用<br> RemoteViews在实际开发中，主要用在通知栏和桌面小部件的开发过程中。主要是通过NotificationManager的notify方法实现的。桌面小部件则是通过AppWidgetProvider来实现的。AppWidgetProvider本质上是一个广播。</p>
<ol>
<li>RemoteViews在通知栏上的应用</li>
<li><p>RemoteViews在桌面小部件上的应用<br> 步骤:</p>
<ol>
<li><p>定义小部件界面</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;ImageView
        android:id=&quot;@+id/imageView1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:src=&quot;@drawable/icon1&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre></li>
<li><p>定义小部件配置信息</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/widget&quot;
    android:minHeight=&quot;84dp&quot;
    android:minWidth=&quot;84dp&quot;
    android:updatePeriodMillis=&quot;86400000&quot; &gt;
&lt;/appwidget-provider&gt;
</code></pre></li>
<li><p>定义小部件的实现类</p>
<pre><code>public class MyAppWidgetProvider extends AppWidgetProvider {

    public static final String TAG = &quot;MyAppWidgetProvider&quot;;
    public static final String CLICK_ACTION = &quot;com.ryg.chapter_5.action.CLICK&quot;;

    public MyAppWidgetProvider() {
        super();
    }

    @Override
    public void onReceive(final Context context, Intent intent) {
        super.onReceive(context, intent);
        Log.i(TAG, &quot;onReceive : action = &quot; + intent.getAction());

        // 这里判断是自己的action，做自己的事情，比如小工具被点击了要干啥，这里是做一个动画效果
        if (intent.getAction().equals(CLICK_ACTION)) {
            Toast.makeText(context, &quot;clicked it&quot;, Toast.LENGTH_SHORT).show();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    Bitmap srcbBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.icon1);
                    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
                    for (int i = 0; i &lt; 37; i++) {
                        float degree = (i * 10) % 360;
                        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);
                        remoteViews.setImageViewBitmap(R.id.imageView1, rotateBitmap(context, srcbBitmap, degree));
                        Intent intentClick = new Intent();
                        intentClick.setAction(CLICK_ACTION);
                        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0);
                        remoteViews.setOnClickPendingIntent(R.id.imageView1, pendingIntent);
                        appWidgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class),remoteViews);
                        SystemClock.sleep(30);
                    }
                }
            }).start();
        }
    }

    /**
     * 每次窗口小部件被点击更新都调用一次该方法
     */
    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        super.onUpdate(context, appWidgetManager, appWidgetIds);
        Log.i(TAG, &quot;onUpdate&quot;);

        final int counter = appWidgetIds.length;
        Log.i(TAG, &quot;counter = &quot; + counter);
        for (int i = 0; i &lt; counter; i++) {
            int appWidgetId = appWidgetIds[i];
            onWidgetUpdate(context, appWidgetManager, appWidgetId);
        }
    }

    /**
     * 窗口小部件更新
     */
    private void onWidgetUpdate(Context context, AppWidgetManager appWidgeManger, int appWidgetId) {
        Log.i(TAG, &quot;appWidgetId = &quot; + appWidgetId);
        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);

        // &quot;窗口小部件&quot;点击事件发送的Intent广播
        Intent intentClick = new Intent();
        intentClick.setAction(CLICK_ACTION);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0);
        remoteViews.setOnClickPendingIntent(R.id.imageView1, pendingIntent);
        appWidgeManger.updateAppWidget(appWidgetId, remoteViews);
    }

    private Bitmap rotateBitmap(Context context, Bitmap srcbBitmap, float degree) {
        Matrix matrix = new Matrix();
        matrix.reset();
        matrix.setRotate(degree);
        return Bitmap.createBitmap(srcbBitmap, 0, 0, srcbBitmap.getWidth(), srcbBitmap.getHeight(), matrix, true);
    }
}
</code></pre></li>
<li><p>在AndroidManifext.xml中声明小部件</p>
<pre><code>&lt;receiver android:name=&quot;.MyAppWidgetProvider&quot; &gt;
&lt;meta-data
    android:name=&quot;android.appwidget.provider&quot;
    android:resource=&quot;@xml/appwidget_provider_info&quot; &gt;
&lt;/meta-data&gt;

&lt;intent-filter&gt;
    &lt;action android:name=&quot;com.ryg.chapter_5.action.CLICK&quot; /&gt;
    &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre><p> </p>
</li>
</ol>
</li>
<li><p>PendingIntent概述</p>
<ol>
<li>PendingIntent含义：<br> PendingIntent表示一种处于pending状态的意图，而pending表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个特定的时刻发生。</li>
<li>PendingIntent和Intent区别：<br> PendingIntent是将来在某个时刻发生，而Intent是立即发生。</li>
<li>使用场景：<br> PendingIntent典型的使用场景是给RemoteViews添加单击事件，因为RemoteViews是运行在远程中，因此RemoteViews不同于普通的View，所以无法直接像View那样通过setOnClickListener方法来设置单击事件。要想给RemoteViews设置单击事件，就必须使用PendingIntent,PendingIntent通过send和cancel方法来发送和取消特定的待定intent。</li>
<li>PendintIntent支持三种特定意图：<ol>
<li>启动Activity:<br> getActivity(Context context,Intent intent,int requestCode,int flags)</li>
<li>启动Service：<br> getService(Context context,Intent intent,int requestCode,int flags)</li>
<li>发送广播:<br> getBroadcast(Context context,Intent intent,int requestCode,int flags)</li>
</ol>
</li>
<li>PendingIntent的匹配规则：<br> requestCode表示PendingIentent发送方的请求码，多情况下设为0即可。requestCode会影响到flags效果。<ol>
<li>如果两个PendingIntent它们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。什么是Intent相同？intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。注意Extras不参与Intent的匹配过程。</li>
<li>flag参数含义：<ol>
<li>FLAG_ONE_SHOT<br> 当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel。</li>
<li>FLAG_NO_CREATE<br> 当前描述的PendingIntent不会主动创建。日常开发中并没有太多的使用意义。</li>
<li>FLAG_CANCEL_CURRENT<br> 当前描述的PendingIntent如果已经存在，那么它们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单击后将无法打开。</li>
<li>FLAG_UPDATE_CURRENT<br> 当前描述的PendingIntent如果已经存在，那么它们都会被更新。即它们的Intent中的Extras会被替换成最新的。</li>
</ol>
</li>
<li>NotificationManager.nofify(id, notification) 几种情况：<ol>
<li>如果notify第一个参数id是常量，那么不管PendingIntent是否匹配，后面的通知会直接替换前面的通知。</li>
<li>如果notify方法的id每次都不同：<ol>
<li>当PendingIntent不匹配时(Intent相同并且requestCode相同)，这种情况性爱不管采用何种标记位。这些通知之间不会相互干扰。</li>
<li>如果PendingIntent处于匹配状态：<ol>
<li>如果采用FLAG_ONE_SHOT标记位，那么后续通知中PendingIntent会后第一条通知保持一致。包括Extras，单机任何一条通知后，剩下的通知均无法再打开，当所有的通知都被消除后，会再次重复这个过程</li>
<li>如果采用FLAG_CANCEL_CURRENT标记位，那么只有最新的通知可以打开，之前弹出的通知均无法打开</li>
<li>如果采用了FALG_UPDATE_CURRENT标记位，那么之前弹出的通知栏中的PendingIntent给被更新，最终它们和最新的一条通知保持完全一致，包括Extras。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>RemoteViews内部机制：</p>
<ol>
<li>RemoteViews常用构造方法：public RemoteViews(String packageName,int layoutIedd),它接收两个参数，第第一个表示当前应用的包名，第一个表示待加载的布局文件。</li>
</ol>
</li>
</ol>
<pre><code>2. RemoteViews只支持部分布局和View组件，下面列举的组件的子类是不支持的 :
布局：FrameLayout、LinearLayout、RelativeLayout、GridLayout
组件：Button、ImageButton、ImageView、TextView、ListView、GridView、ViewStub等

3. RemoteViews没有提供findViewById方法，因此无法直接访问里面的View元素。必须通过RemoteViews所提供的一些列set方法来完成。


4. 通知栏和桌面小部件分由：NotificationManager和AppWidgetManager管理。NotificationManager和AppWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService以及，AppWidgetService进行通信。由此可见，通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的，而它们运行在系统的SystemServer中，这就和我们的进程构成了跨进程构成了跨进程通信的场景。


5. RemoteViews实现了Parcelable接口，通过Binder传递到SystemServer进程，系统根据RemoteViews中使用的包名等信息去得到该应用的资源。然后加载布局文件。


6. 系统会对View执行一些列界面更行任务。这些任务是通过之前的set方法提交的。RemoteViews会记录这些更新操作，RemoteViews被加载后，这些更新操作才会被执行。


7. 系统将View操作封装到Action对象并将这些对象跨进程传输到远程进程，接着在远程进程中执行Action对象中的具体操作。


8. 我们在应用中每调用一次set方法，RemoteViews中就会添加一个对应的Action对象，当我们提交更新时，遍历调用他们它们的apply方法来进行View的更新操作。


9. apply和reApply的区别在于：apply会加载布局并更新界面。通知栏和桌面小插件在初始化界面时会调用apply方法，而在后续更新界面时调用reapply方法。


10. setOnClickPendingIntent、setPendingIntentTemplate、setOnClickFillInIntent区别和联系：
    1. setOnClickPendingIntent用于给普通View设置单击事件，但是不能给集合（ListView）中的View设置单击事件，因为开销比较大，所以禁止这种方式。
    2. 如果要给ListView和StackView中的item添加单击事件，则必须将setPendingInntentTemplate和setOnClickFillInIntent组合使用才可以。
</code></pre><ol>
<li>RemoteViews意义<br> 实现了跨进程UI更新。</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第二章/第二章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二章-IPC机制"><a href="#第二章-IPC机制" class="headerlink" title="第二章 IPC机制"></a>第二章 IPC机制</h2><ol>
<li><p>Android IPC简介</p>
<blockquote>
<p>IPC 含义为进程间通信，是指两个进程间进行数据交换的过程。<br>在Android 中最有特色的进程间通信方式就是Binder,通过Binder可以轻松地实现进程间通信。同时，Android还支持Socket通信</p>
</blockquote>
</li>
<li><p>Android中的多进程模式</p>
<ol>
<li><p>开启多进程模式<br> 方法只有一个，就是在AndroidMenifest中给四大组件指定android:process属性。  </p>
<ol>
<li>“com.ryg.chapter_2.remote”<br> 这是一种完整的命名方式，属于全局进程，其他应用可以通过ShareUID方式可以和它跑在同一个进程。</li>
<li>“com.ryg.chapter_2:remote”<br> 是指在当前进程名前面附加上当前的包名，这是一种简写的方法。进程名以”:”开头的进程属于当前应用的私有进程，其他应用进程不可以和它跑同一个进程。  </li>
</ol>
</li>
<li><p>多进程模式的运行机制</p>
<ol>
<li>Android为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多个副本。</li>
<li>所有运行在不同进程中的四大组建爱你，只要它们只要需要通过内存来共享数据，都会共享失败，这也是多进程带来的影响。</li>
<li><p>多进程造成的问题：</p>
<ol>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharePreference可靠性降低</li>
<li>Application会多次创建</li>
</ol>
</li>
<li><p>多模式中，不同进程的组件会拥有独立的虚拟机、Application、以及内存空间。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>IPC基础概念 </p>
<ol>
<li>Serializable接口<ol>
<li>采用Serializable方式序列化对象，只需要把实现了Serializable接口的对象写入到文件中就可以快速恢复了，恢复后的对象和之前的对象<strong>内容</strong>完全一样，但是两者并不是同一个对象。</li>
<li>serialVersionUID的工作机制:序列化的时候，系统会把当前类的serialVersionUID写入到序列化的文件中，当反序列化的时候，系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的版本和当前的版本是相同的，可以成功反序列化。否则说明发生了变化。</li>
<li>静态成员变量属于类，不属于对象，所以不会参与序列化过程。其次使用了transient关键字标记的成员变量不参与序列化过程。</li>
</ol>
</li>
<li><p>Parcelable接口</p>
<ol>
<li>Android提供的新的序列化接口。</li>
<li>Itent、Bundle、Bitmap都实现了Parcelable接口。</li>
</ol>
</li>
<li><p>Binder</p>
<ol>
<li>工作机制:<br> <img src="http://i.imgur.com/ZE2APJG.png" alt="Binder工作机制"></li>
</ol>
</li>
<li><p>Android 中的IPC方式</p>
<ol>
<li>使用Bundle<br> 传输的数据必须能够被序列化，比如基本数据类型，实现了Parcellable接口的对象，实现了Seriallizable接口的对象，以及一些Android支持的特殊对象。</li>
<li>使用文件共享<br> Android 系统基于Linux，使得其并发读写文件可以没有限制的进行，甚至两个线程同时对一个文件进行写操作都是允许的。<br> 文件共享方式适合在对数据同步要求不高的进程之间进行通信。不建议在进程间通信中使用SharedPreferences</li>
<li>使用 Messager<br> Messager一次处理一个请求，因此在服务端不用考虑线程同步问题。 <img src="http://i.imgur.com/cx0fkLl.png" alt="Message工作原理"></li>
<li>使用AIDL<br> 使用AIDL跨进程调用服务端方法<ol>
<li>进程间通信的流程<ol>
<li>服务端：<br>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可</li>
<li>客户端:<br>客户端首先绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</li>
</ol>
</li>
<li>实现解注册功能:<br> RemoteCallbckList是系统专门提供用于删除跨进程listener的接口。RemoteCallbackList 内部自动实现了线程同步功能，使用它来注册和解注册时，不需要做额外的线程同步工作。</li>
<li>重新连接远程服务<ol>
<li>给Binder设置DeathRecipient监听，当Binder死亡时，我们会收到binderDied方法的回调，在binderDied方法中，我们可以重新连接远程服务。</li>
<li>在onServiceDisconnected中重新连接远程服务。</li>
<li>以上两种方法的区别，onServiceDisconnected在客户端的UI线程中被回调。binderDied在客户端的Binder线程池中被回调。</li>
</ol>
</li>
<li>在AIDL中设置权限功能<ol>
<li>使用permission验证，在onBind中验证，验证不通过，返回null</li>
<li>在服务端的onTransact方法中进行权限验证，验证失败返回false。</li>
</ol>
</li>
</ol>
</li>
<li>使用ContentProvider </li>
<li>使用socket</li>
</ol>
</li>
<li><p>Binder线程池<br> 工作机制:<br> 每个验证模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间不能有耦合，所有的实现细节要单独分开，然后向客户端提供自己的唯一标识和对应的Binder对象；对于服务端来说，只需要一个Service就可以了，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder给他们，不同业务模块拿到所需要的Binder对象就可以进行远程方法的调用了。  </p>
<p>6.选择合适的IPC方式<br><img src="http://i.imgur.com/s3cQRVf.png" alt="IPC方式优缺点"></p>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第九章/第九章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第三章/第三章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第三章View的事件体系"><a href="#第三章View的事件体系" class="headerlink" title="第三章View的事件体系"></a>第三章View的事件体系</h3><ol>
<li><p>View基础知识</p>
<ol>
<li>什么是View?<br> View是Android中所有控件的基类。View是一种界面层控件的一种抽象，它代表了一个控件。ViewGroup也是继承自View</li>
<li>View的位置参数<br> View 的位置主要是由它的四个顶点来决定的，分别对应于View的四个属性：top、left、right、bottom.这些坐标都是相对于View的父容器来说的，是一种相对坐标。</li>
<li><p>MotionEvent 和 TouchSlop</p>
<ol>
<li><p>MotionEvent</p>
<blockquote>
<p>手指解除屏幕后所产生的一系列事件中，典型的事件类型有如下几种：  </p>
</blockquote>
<ol>
<li>ACTION_DOWN-手指刚接触屏幕</li>
<li>ACTION_MOVE-手指在屏幕上移动</li>
<li><p>ACTION-UP-手指从屏幕上松开的一瞬间</p>
<blockquote>
<p>正常情况下，一次手指触摸屏幕的行为会触发一些列点击事件，考虑有如下几种:  </p>
</blockquote>
</li>
<li><p>点击屏幕后松开:事件序列为DOWN-&gt;UP</p>
</li>
<li>点击屏幕滑动一会再松开，事件序列DOWN-&gt;MOVE-&gt;..-&gt;UP</li>
</ol>
</li>
<li><p>TouchSlop  </p>
<blockquote>
<p>TouchSlop是系统所能识别出的被认为是滑动最小的距离。这是一个常量，和设备有关，在不同的设备上，值可能有所不同。 通过ViewConfiguration.get(getContext()).getScaledTouchSlop().</p>
</blockquote>
</li>
</ol>
</li>
<li>VelocityTracker 、GestureDetector 和Scroller<ol>
<li>VelocityTracker<br> 速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向上的速度。</li>
<li>GestureDetector<br> 手势检测，用户辅助检测用户的单击、滑动、长按、双击等行为。参考建议: 如果只是监听滑动相关的，建议自己在onTouchEvent中实现，如果要监听双击这种行为，那么使用GestureDector</li>
<li>Scroller<br> 弹性滑动对象，用于实现View的弹性滑动。使用Scroller实现有过渡效果的滑动。</li>
</ol>
</li>
</ol>
</li>
<li><p>View的滑动 </p>
<ol>
<li>使用scrollTo/srollBy<br> scrollBy实际上也是调用了scrollTo方法。使用srollTo和scrollBy来实现View的滑动，只能将View的内容进行移动，并不能将View本身进行移动。</li>
<li><p>使用动画</p>
<ol>
<li><p>View传统动画    </p>
<pre><code>&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:fillAfter=&quot;true&quot;
    android:zAdjustment=&quot;normal&quot; &gt;

    &lt;translate
        android:duration=&quot;100&quot;
        android:fromXDelta=&quot;0&quot;
        android:fromYDelta=&quot;0&quot;
        android:interpolator=&quot;@android:anim/linear_interpolator&quot;
        android:toXDelta=&quot;100&quot;
        android:toYDelta=&quot;100&quot; /&gt;

&lt;/set&gt;
</code></pre></li>
<li><p>采用属性动画  </p>
<pre><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start()
</code></pre><blockquote>
<p>View动画是对View的影像操作，它并不能真正改变View的位置参数，包括宽高</p>
</blockquote>
</li>
</ol>
</li>
<li>改变布局参数<br> 改变LayoutParams里面的参数</li>
<li>以上三种方式的对比：    <ol>
<li>scrollTo/scrollBy：操作简单，适合对View内容的滑动，并不能滑动内容本身。</li>
<li>动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果。</li>
<li>改变参数布局:操作稍微复杂，适用于有交互的View</li>
</ol>
</li>
</ol>
</li>
<li><p>弹性滑动  </p>
<blockquote>
<p>主要思想: 将一次大的滑动分成若干次小的滑动并在一个时间段内完成。</p>
<ol>
<li>使用Scroller<br> <strong>工作机制:</strong>scroller本身并不能实现View的滑动，它需要配合View的computeScroll方法才能完成弹性滑动效果，它不断让View重绘，而每一次重回滑动起始时间会有一个时间间隔，通过这个间隔Scroller就可以得出View当前的滑动位置，知道了滑动位置，就可以通过scrollTo方法来完成View的滑动。就这样，View的每一次重绘都会导致View进行小幅度的滑动，而小幅度的滑动就组成了弹性滑动。</li>
<li>通过动画<br> 动画本身就是一种渐进的过程，因此通过它来实现的滑动天然就具有弹性效果。动画的本质上没有作用于任何对象上，它只是在1000ms内完成了整个动画过程。利用这个特性，我们就可以在动画的每一帧到来时获取动画完成的比例，然后再根据这个比例计算出当前view所要滑动的距离。</li>
<li>使用延时操作<br> <strong>核心思想:</strong>通过发送一系列延时消息从而达到一种渐进式的效果，具体来说可以是使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。对于postDelayed方法来说，我们可以通过它来延时发送一个消息，然后在消息中来进行view滑动，如果接连不断地发送这种延时消息，那么就可以实现弹性滑动的效果。对于sleep方法来说，通过在while循环中不断地滑动view和sleep，就可以实现弹性滑动的效果。</li>
</ol>
</blockquote>
</li>
<li><p>View的事件分发机制  </p>
<blockquote>
<p>View的一个难题是滑动冲突，它的理论基础就是事件分发机制，因此掌握好事件分发机制。  </p>
<ol>
<li>点击事件的传递规则<br>点击事件的分发过程由三个很重要的方法来完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent<ol>
<li>dispatchTouchEvent(MotionEvent event): 用来进行事件分发。如果事件能够传递当前View，那么此方法一定会被调用，返回结果受当前view的onTouchEvent和下级的dispatchTouchEvent方法的影响，表示是否消耗当前的事件。</li>
<li>onInterceptTouchEvent(MotionEvent event) 用来判断是否拦截某个view如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次被调用，返回结果表示是否拦截此当前事件。</li>
<li>onTouchEvent(MotionEvent event) 用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，在同一事件序列中，当前view无法再次接收到事件。</li>
<li>三个方法之间的关系,用如下伪代码表示:</li>
</ol>
</li>
</ol>
</blockquote>
<pre><code>         public boolean dispatchTouchEvent(MotionEvent motionEvent) {
                boolean consume = false;
                //如果当前view拦截事件
                if (onInterceptTouchEvent(motionEvent)) {
                    //当前view是否消耗当前事件
                    consume = onTouchEvent(motionEvent);
                } else {
                    //不拦截,问子结点
                    consume = child.dispatchTouchEvent(motionEvent);
                }
                return consume;
            }

5. 点击事件的传递规则:  
    对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true，表示它要拦截当前事件，接着ViewGroup的onTouchEvent方法就会被调用；如果onInterceptTouchEvent返回false，表示不拦截当前事件，这个事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此返回循环，直到事件最终被处理。
6. 当一个view需要处理事件时，如果它设置了onTouchListener，那么onTouchListener中的onTouch方法会被调用,如果这个onTouch方法返回false，那么当前view的onTouch方法会被调用；返回返回true，当前view的onTouch方法则不会被调用。由此可见，onTouchListener优先级比view的onTouch方法要高。平时我们常用的onClickListener优先级最低。  
优先级顺序: onTouchListener-&gt;view 的onTouch方法-&gt; onClickListener
7. 当一个点击事件产生后，它的传递顺序:Actvity-&gt;Window-&gt;View.事件总是先传递给Activity、Activity再传递给Window,最后Window再传递给顶级的View。顶级View接收到事件后，就会按照事件分发机制去分发事件。如果一个view的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用。以此类推，如果所有的元素都不处理这个事件，那么这个事件将最终传递给Activity的onTouchEvent方法。
8. 某个View一旦决定拦截，那么这一个事件序列都只能由它来处理，并且它的onInterceptTouchEvent不会再被调用。
9. 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交给它的父元素去处理。
</code></pre><ol>
<li><p>事件分发的源码解析</p>
<ol>
<li><p>一旦事件由当前ViewGroup拦截时，ViewGroup的onInterceptTouchEvent不会再被调用，有一种特殊情况，通过reqeustDisallowInterceptTouchEvent方法设置了FLAG_DISALLOW-INTERCEPT标记位后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他方法。因为ViewGroup会在ACTION_DWON事件到来时做重置状态操作。</p>
<blockquote>
<p>分析对我们有什么价值?</p>
</blockquote>
<ol>
<li>onInterceptTouchEvent()不是每次事件都会被调用的如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会被调用。前提事件能够传递到当前的ViewGroup</li>
<li>FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以考虑用这个方法去解决问题。</li>
</ol>
</li>
<li><p>ViewGroup不拦截事件时,首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件（是否能够接收由两点衡量:1.子元素是否在播动画，2.点击事件是否落在子元素的区域内，任意一个即可）。然后接着调用子元素的dispatchTouchEvent方法，这样事件就交给了子元素处理。如果子元素的dispatchTouchEvent返回true，终止对子元素的遍历，跳出循环；如果返回false,ViewGroup就会把事件分发给下一个子元素。</p>
</li>
<li>如果遍历了所有的子元素后事件都没有被合理的处理（第一种:ViewGroup没有子元素；第二种子元素处理的点击事件，但是在dispatchTouchEvent返回了false，一般是子元素的onTouchEvent中返回了false。）。这两种情况下，ViewGroup会自己处理点击事件。</li>
</ol>
</li>
<li><p>View对点击事件的处理过程</p>
<ol>
<li>先判断有没有设置onTouchListener，如果onTouchListenr中的onTouch返回true,View中onTouchEvent(event)将不会被调用</li>
<li>view处于不可用状态下，View照样会消耗点击事件。</li>
<li>只要View的CLICKABLE和LONG_CLICKABLE有一个为true，不管它是不是DISABLE状态，它就会消耗这个事件。</li>
<li>setOnClickListener会自动将View的CLICKABLE设为true，setOnLongClickListener会自动将View的LONG_CLICKABLE设为true。</li>
</ol>
</li>
</ol>
</li>
<li><p>View的滑动冲突  </p>
<ol>
<li>常见滑动冲突      <ol>
<li>外部滑动方向和内部滑动方向不一致，例如：ViewPager中包含listView  </li>
<li>外部滑动方向和内部滑动方向一致，例如，两个ViewPager的嵌套  </li>
<li>上面两种情况的嵌套。  </li>
</ol>
</li>
<li>滑动冲突的处理规则：<ol>
<li>可以根据滑动路径和水平方向所形成的水平方向的夹角。</li>
<li>在业务上找到突破口</li>
</ol>
</li>
<li><p>滑动冲突的解决方式：</p>
<ol>
<li><p>外部拦截法：<br> 点击事件都经过服务器的拦截处理，如果父亲容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。伪代码如下：</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastXIntercept;
        int deltaY = y - mLastYIntercept;
        if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }

    mLastXIntercept = x;
    mLastYIntercept = y;

    return intercepted;
} 
</code></pre></li>
<li><p>内部拦截法：父容器不拦截诶任何事件，所有事件都传递给子元素，如果子元素需要此事件，就消耗掉，，否则就交由父容器进行处理，这种方法和Android中的事件分发机会不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。伪代码如下:</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {]
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            getParent().requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre><blockquote>
<p>除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其它事件。父元素伪代码：</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code> public boolean onInterceptTouchEvent(MotionEvent motionEvent) {
    int action = motionEvent.getAction();
    if (action = MotionEvent.ACTION_DOWN) {
        return false;
    } else {
        return true;
    }
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第七章/第七章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第七章、Android动画深入分析"><a href="#第七章、Android动画深入分析" class="headerlink" title="第七章、Android动画深入分析"></a>第七章、Android动画深入分析</h3><pre><code>&gt; Android动画可以分为三种：View动画，帧动画、属性动画。其实帧动画也属于View动画，只不过它和平移、旋转等常见的View动画在表现形式上略有不同而已。
</code></pre><ol>
<li>View动画<br> View动画的作用对象是View，支持四种动画：平移、缩放、旋转、透明度。<ol>
<li>View动画的种类  <ol>
<li>View动画的四种变化效果对应着Animation的四个子类：TanslateAnimation 、ScaleAnimation、RetateAnimation和AlphaAnimation。</li>
<li>对于view动画来说，建议采用XML来定义动画，因为可读性更好。</li>
</ol>
</li>
<li>帧动画<br> 帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于View动画，系统提供了另外一个类AnimationDrawable来使用帧动画。帧动画起来容易引起OOM，所以在使用帧动画时应尽量避免使用过多尺寸较大的图片</li>
</ol>
</li>
<li><p>View动画使用场景<br> 在ViewGroup中可以控制子元素的出场效果，在Activity中可以实现不同Activity之间的切换效果。</p>
<ol>
<li><p>LayoutAnimation<br> LayoutAnimation作用于ViewGroup，为ViewGroup指定一个动画，这样当它的子元素出场时都会具有这种动画效果。<br> 代码示例：  </p>
<pre><code>&lt;layoutAnimation
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:delay=&quot;0.5&quot;
    android:animationOrder=&quot;reverse&quot;
    android:animation=&quot;@anim/anim_item&quot;/&gt;
</code></pre><p> 属性的含义:     </p>
<ol>
<li>android:dely:<br> 表示子元素开始动画的时间延迟。比如子元素入场动画的时间周期是300ms，那么0.5表示每个子元素都需要延迟150ms才能播放入场动画。</li>
<li>android:animationOrder:<br> 表示子元素的出场顺序，有三种选项：normal、reverse和random。</li>
<li>android:animation<br> 为子元素指定具体的入场动画。  </li>
</ol>
</li>
<li>Activity的切换效果  <ol>
<li>Activity有默认的切换效果，但是这个效果可以自定义。主要用到了overridePendingTransition(int enterAnim,int exitAnim)这个方法。这个方法必须在startActivity(Intent)或者finish()之后被调用才能生效。</li>
</ol>
</li>
</ol>
</li>
<li><p>属性动画 </p>
<ol>
<li>使用属性动画<br> 在实际开发中建议采用代码来实现属性动画，因为通过代码来实现比较简单。更重要的是，很多时候一个属性无法提前确定。逼图让一个Button从屏幕左边移动到屏幕的右边，由于我们无法提前知道屏幕的宽度，因此无法将属性动画定义在XML中，在这种情况下就必须通过代码动态地创建属性动画。</li>
<li>理解插值器和估值器<ol>
<li>TimeInterpolator，时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性改变的百分比。系统内置的插值器有线性插值器(LinearInterpolator)、加速减速插值器(AccelerateDecelerateInterpolator)和减速插值器(DecelerateInterpolator)。</li>
<li>TypeEvaluator,类型估值算法，它的作用是根据当前属性改变的百分比来计算改变后的属性值。系统内置的估值器有IntEvaluator、FloatEvaluator和ArgbEvaluator。</li>
</ol>
</li>
<li>属性动画监听器  <pre><code>属性动画提供了监听器用于监听动画的播放过程，主要有两个接口：AnimatorUpdateListener和AnimatorListener。为了开发方便，系统提供了AnimatorListenerAdapter这个类，这是AnimatiorListener的适配器，这样我们可以有选择性的实现方法。
</code></pre></li>
<li><p>对任意属性做动画  </p>
<pre><code>View不支持对宽度进行动画。
</code></pre><ol>
<li>属性动画的原理： <pre><code>属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说随着时间的推移，所传递的值越来越接近最终值。
</code></pre></li>
<li><p>我们对object的属性abc做动画，如果想要动画生效，需要同时满足两个条件：</p>
<pre><code>1. object必须提供setAbc方法，如果动画的时候没有传递初始值，那么还要提供getAbc方法，因为系统要去取abc属性的初始值。
2. Object的setAbc属性对abc所做的改变必须更够通过某种方法反应出来，比如会带来UI的改变之类的。
</code></pre></li>
<li><p>对Button的width属性做动画没有效果？  </p>
<pre><code>因为Button内部的setWidth并不是改变视图的大小，所以Button并不满足条件2，有三种解决方法:  
1. 给你的对象加上get和set方法，如果有权限的话。
2. 用一个类来包装原始对象，间接为其提供get和set方法。
3. 采用ValueAnimator，监听动画过程，自己实现属性的改变。
</code></pre></li>
</ol>
</li>
<li><p>属性动画的工作原理  </p>
<ol>
<li>属性动画要求动画的作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递个set方法的值都不一样，确切来说，随着时间的推移，所传递的值越来越接近最终值。</li>
<li>属性动画需要运行在有Looper的线程中。</li>
</ol>
</li>
</ol>
</li>
<li><p>是使用动画注意事项  </p>
<ol>
<li>OOM：尽量避免使用帧动画，使用的话应尽量避免使用过多尺寸较大的图片；</li>
<li>内存泄露：属性动画中的无限循环动画需要在Activity退出的时候及时停止，否则将导致Activity无法释放而造成内存泄露。view动画不存在这个问题；<br>3.兼容性问题：某些动画在3.0以下系统上有兼容性问题；</li>
<li>view动画的问题：view动画是对view的影像做动画，并不是真正的改变view的状态，因此有时候动画完成之后view无法隐藏，即setVisibility(View.GONE)失效了，此时需要调用view.clearAnimation()清除view动画才行。</li>
<li>不要使用px；</li>
<li>动画元素的交互：在android3.0以前的系统上，view动画和属性动画，新位置均无法触发点击事件，同时，老位置仍然可以触发单击事件。从3.0开始，属性动画的单击事件触发位置为移动后的位置，view动画仍然在原位置；</li>
<li>硬件加速：使用动画的过程中，建议开启硬件加速，这样会提高动画的流畅性。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/第一章/第一章/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##第一章 Activity的生命周期和启动模式</p>
<ol>
<li>生命周期全面分析<ol>
<li><strong>典型情况</strong> : 正常情况启动Activity<ol>
<li>第一次启动某个特定Activity,回调:onCreate()-&gt;onStart()-&gt; onResume()</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>    2. 用户打开新的Activity或者切换到桌面，回调如下:onPause()-&gt; onStop(),如果Activity采用了透明主题，当前Activity不会调用onStop().


    3. 再次回到原来的Activity时，调用如下:onRestart-&gt;onStart()-&gt;onResume()


    4. onStart()、onStop()是从Activity是否可见的角度来回调的，onResume、onPause()是从是否位于前台的角度来回调的。


    5. 当前Acitivity为A,此时用户打开了一个新的Activity为B.此时A、B各自的调用顺序. onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B)-&gt;onStop(A)


    6. 不能在onPause()、onStop()中做耗时操作。资源回收等操作应该在onStop()中操作

2. **异常情况** ：例如屏幕旋转、系统配置发生变化，资源内存不足导致低优先级的Acitivity被杀死。
    1. 系统配置发生改变后，Activity会被销毁，系统会调用onSaveInstanceState()来保存当前Acitiviyt的状态，该方法在onStop()之前调用，onPause()前后都有可能。当Activity被重新创建后，系统会调用onRestoreInstanceState()，该方法在onStart()之后调用。
    ![Activity异常情况重建过程](http://i.imgur.com/7xJA5pg.png)

    2. Activity销毁被重建，获取之前的存储，接收的位置可以是onCreate()或者onRestoreInstanceState()了，两者的区别，onRestoreInstanceState()一旦被调用，其参数Bundle savedInstanceState一定是有值的。onCreate()不行，onCreate()正常启动savedInstanceState为空。所以必须要进行额外判断。

    3. onSaveInstanceState 方法还有一点需要说明，那就是系统只会在Activity即将被销毁并且有机会重新显示的情况下才会调它。例如，屏幕发生旋转。Activity正常销毁不会调用。

    4. Acitivity优先级情况
        1. 前台Activity. 正与用户交互，优先级最高。
        2. 可见非前台Acitivity . 比如Activity弹出一个对话框，导致Acitivity可见但是位于后台无法与用户直接交互。
        3. 后台Activity. 已经被暂停的Activity ，优先级最低。

    5. 某项内容发生改变后，不想系统重新创建Acitivity.可以给Acitivity指定configChanges属性。例如：
        &gt; android:configChanges=&quot;orientation&quot;
</code></pre><ol>
<li><p>Acitivity的启动模式</p>
<ol>
<li><p>各种启动模式:</p>
<ol>
<li><p>standard模式： 该模式下，，谁启动了这个Acitivity,那么这个Activity就运行在启动它的那个Acitivity所在的栈中。 <strong>由于非Activity类型的Context（例如ApplicationContext）并没有的所谓的任务栈。解决这个问题的方法就是为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个的新的任务栈。</strong></p>
</li>
<li><p>singleTop模式:栈顶复用模式，如果新的Activity已经位于任务栈顶，此Activity不会被重新创建，同时它的onNewIntent（）方法会被回调。这个Activity的onCreate() 、onStart() 、onResume()方法不会被调用。</p>
</li>
<li><p>singleTask模式:栈内复用模式。常见的几种情况:</p>
<ol>
<li><p>当前任务栈S1中的情况为:ABC,这个时候Activity D以singleTask模式请求启动，所需要的任务栈为S2,由于S2和D都不存在，所以系统会先创建任务栈S2，然后再创建D的实例将其压入栈S2</p>
</li>
<li><p>假设D所需要的任务栈为S1,由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1.</p>
</li>
<li><p>如果D所需要的任务栈为S1,当前任务栈S1的情况为ADBC,此时D不会被重新创建，系统会把D切换到栈顶并调用其onNewIntent方法。同时D上面所有的Activity全部出栈。</p>
<blockquote>
<ol>
<li>假设目前有两个任务栈，前台任务栈的情况为AB，后台任务栈的情况为CD，假设CD的启动模式均为singleTask,现在请求D,那么整个后台任务栈都会被切换到前台，这个时候整个后退列表变成了ABCD，当用户按back 时，列表的Activity会一一出栈.  </li>
<li>和上面情况一样，当请求启动的是C，那么后台任务栈的D先出栈，然后，后台任务栈会切换到前台，整个后退列表变成了ABC</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>SingleInstance:单实例模式:此种模式的Acitivity只能单独地位于一个任务栈。比如Activity A是singleInstance 模式，当A启动后，系统会为它建一个新的任务栈。然后A单独在这个新的任务栈中，由于栈内复用的特性，后序均不会创建新的任务栈。</p>
</li>
<li><p>什么是任务栈?<br>TaskAffinity,任务相关性。标识一个Activity所需要的任务栈的名字。默认情况下，所需要的任务栈的名字为应用的包名。<br>TaskAffinity主要和singleTask启动模式或者allowTaskReparenting属性相配对使用。<br>任务栈分为前台和后台任务栈，后台任务栈Activity位于暂停状态，用户可以通过切换将后台任务栈再次调用到前台。  </p>
<ol>
<li>和singleTask启动模式使用<br> 待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。</li>
<li>和alloTaskReparenting结合<br> 比如现在有两个应用A、B。A启动了B一个ActivityC，然后，按Home键回到了桌面，然后再单击B的桌面图标，这个时候并不是启动了B的主Activity.而是重新显示已经被应用A启动的AtivityC。<br> 由于A启动了C,这个时候ActivityC只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity不可能和A的任务栈相同，所以B被启动后，B会创建自己的任务栈，这个时候系统发现C原本想要的任务栈已经被创建了了，所以就把C从A的任务栈中转移过来了。</li>
</ol>
</li>
<li>给Activity指定启动模式？<ol>
<li>通过AndroidMenifest指定</li>
<li>通过在Intent中设置标志位来为Activity指定启动模式。  <blockquote>
<p>两者区别：<br>1.标志位优先级更高。<br>2.第一种无法设定FLAG_ACTIVITY_CLEAR_TOP,第二种无法指定singleInstance模式。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Ativity 的flags</p>
<blockquote>
<p>Activity 的flags有很多。常用作用，比如设定启动模式，还有的可以影响Activity的运行状态</p>
</blockquote>
</li>
</ol>
</li>
<li><p>IntentFilter 的匹配规则</p>
<ol>
<li>action匹配规则<br> action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同。</li>
<li>category匹配规则<br> 与action匹配过程不同的是，action要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求intent中可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。</li>
<li>data匹配规则<br> data匹配规则和action类似，它也要求Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/艺术探索读书笔记/《Android开发艺术探索》书中源码/android-art-res-master/README/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T11:45:41+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="android-art-res"><a href="#android-art-res" class="headerlink" title="android-art-res"></a>android-art-res</h1><p>《Android开发艺术探索》书中源代码</p>
<p><img src="http://218.249.32.138/covers/9787121269394.jpg" width="400" alt="cover"></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="xfshiapn" />
          <p class="site-author-name" itemprop="name">xfshiapn</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xfshipan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1978471290" target="_blank" title="Weibo">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xfshiapn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
